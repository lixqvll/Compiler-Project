%{ 
    #include <stdio.h> 
    #include <string.h> 
    #include "parserR.tab.h" 
 
    extern int token_count; 
    extern int symbol_count; 
    extern char* symbol_table[]; 
    #define MAX_SYMBOLS 100 
 
    void add_symbols(const char* word){ 
        for (int i =0 ; i < symbol_count; i++){ 
            if (strcmp(symbol_table[i],word)==0) 
                return; 
        } 
        if (symbol_count < MAX_SYMBOLS){ 
            symbol_table[symbol_count] = strdup(word); 
            symbol_count++; 
        } 
    } 
%} 
 
%% 
 
"and"         { printf("KEYWORD: %s\n", yytext); token_count++; return AND; } 
"begin"       { printf("KEYWORD: %s\n", yytext); token_count++; return BEGIN_T; } 
"forward"     { printf("KEYWORD: %s\n", yytext); token_count++; return FORWARD; } 
"div"         { printf("KEYWORD: %s\n", yytext); token_count++; return DIV; } 
"do"          { printf("KEYWORD: %s\n", yytext); token_count++; return DO; } 
"else"        { printf("KEYWORD: %s\n", yytext); token_count++; return ELSE; } 
"end"         { printf("KEYWORD: %s\n", yytext); token_count++; return END; } 
"for"         { printf("KEYWORD: %s\n", yytext); token_count++; return FOR; } 
"function"    { printf("KEYWORD: %s\n", yytext); token_count++; return FUNCTION; } 
"if"          { printf("KEYWORD: %s\n", yytext); token_count++; return IF; } 
"array"       { printf("KEYWORD: %s\n", yytext); token_count++; return ARRAY; } 
"mod"         { printf("KEYWORD: %s\n", yytext); token_count++; return MOD; } 
"not"         { printf("KEYWORD: %s\n", yytext); token_count++; return NOT; } 
"of"          { printf("KEYWORD: %s\n", yytext); token_count++; return OF; } 
"or"          { printf("KEYWORD: %s\n", yytext); token_count++; return OR; } 
"procedure"   { printf("KEYWORD: %s\n", yytext); token_count++; return PROCEDURE; } 
"program"     { printf("KEYWORD: %s\n", yytext); token_count++; return PROGRAM; } 
"record"      { printf("KEYWORD: %s\n", yytext); token_count++; return RECORD; } 
"then"        { printf("KEYWORD: %s\n", yytext); token_count++; return THEN; } 
"to"          { printf("KEYWORD: %s\n", yytext); token_count++; return TO; } 
"type"        { printf("KEYWORD: %s\n", yytext); token_count++; return TYPE; } 
"var"         { printf("KEYWORD: %s\n", yytext); token_count++; return VAR; } 
"while"       { printf("KEYWORD: %s\n", yytext); token_count++; return WHILE; } 
 
"+"           { printf("SYM: +\n"); token_count++; return PLUS; } 
"-"           { printf("SYM: -\n"); token_count++; return MINUS; } 
"*"           { printf("SYM: *\n"); token_count++; return MUL; } 
"="           { printf("SYM: =\n"); token_count++; return EQUAL; } 
"<="          { printf("SYM: <=\n"); token_count++; return LTE; } 
">="          { printf("SYM: >=\n"); token_count++; return GTE; } 
"<>"          { printf("SYM: <>\n"); token_count++; return NEQ; } 
">"           { printf("SYM: >\n"); token_count++; return GT; } 
"<"           { printf("SYM: <\n"); token_count++; return LT; } 
"."           { printf("SYM: .\n"); token_count++; return DOT; } 
","           { printf("SYM: ,\n"); token_count++; return COMMA; } 
":"           { printf("SYM: :\n"); token_count++; return COLON; } 
";"           { printf("SYM: ;\n"); token_count++; return SEMICOLON; } 
":="          { printf("SYM: :=\n"); token_count++; return ASSIGN; } 
".."          { printf("SYM: ..\n"); token_count++; return DOTDOT; } 
"("           { printf("SYM: (\n"); token_count++; return LPAREN; } 
")"           { printf("SYM: )\n"); token_count++; return RPAREN; } 
"["           { printf("SYM: [\n"); token_count++; return LBRACKET; } 
"]"           { printf("SYM: ]\n"); token_count++; return RBRACKET; } 
 
[a-zA-Z_][a-zA-Z0-9_]*   { printf("ID: %s\n", yytext); add_symbols(yytext); token_count++; return ID; } 
[0-9]+                  { printf("INT: %s\n", yytext); token_count++; return INT; } 
\"[^\"]*\"              { printf("STR: %s\n", yytext); token_count++; return STR; } 
\{[^}]*\}               {/* ignore comments completely */ } 
[ \t\n\r]+    { /* ignore whitespace completely */ } 
 
. { 
    if (yytext[0] != '\n' && yytext[0] != '\r' && yytext[0] != '\t' && yytext[0] != ' ') 
        printf("UNKNOWN: %s\n", yytext); 
    token_count++; 
} 
 
%%
int yywrap() {

    return 1;
}











